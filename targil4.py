# -*- coding: utf-8 -*-
"""Targil4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12B0eMrEwRHfRGzqZ2jZMkYj0l4vsFfSw
"""

#Targil 4 

####### In class the lecturer told us not to do the part in the cartridge size checking exercise  #######

# Ranit Zohar , 
#Aviah Miriam Yadler , 

from tailrecurse import *

import time

# Targil 4, 1: The imperative
tic = time.time()
L1=[]
i=1
while i<=10000:
    L1.append(i)
    i+=1
print(L1)    
toc = time.time()
(toc-tic)*1000

# Targil 4, 1: The functional, Tail recursion
def fact4():
  @tail_call_optimized
  def func(x=1, result=[ ]):
    if x>10000:
      return result
    return func(x+1, result +[x])
  return func() 

tic = time.time()
print(fact4())  
toc = time.time()
(toc-tic)*1000

#Targil 4, 1: The functional, Regular recursion
import sys
sys.setrecursionlimit(11100)
new_limit = sys.getrecursionlimit()
print(new_limit)

def func(x):
  if x >10000:
    return []
  return  [x]+ func(x+1)

tic = time.time()
L=func(1)
print(L)
toc = time.time()
(toc-tic)*1000

# Targil 4, 2: The imperative
tic = time.time()
L1=[]
i=1
while i<=10000:
    L1.append(i)
    i+=1

summ=sum(L1)

print(summ)

toc = time.time()
(toc-tic)*1000

# Targil 4, 2: The functional, Tail recursion
def fact4():
  @tail_call_optimized
  def func(x=1, result=[ ]):
    if x>10000:
      return result
    return func(x+1, result +[x])
  return func() 

def tail_recursive_array_sum(arr, arr_sum=0):
    if len(arr) == 0:
        return arr_sum
    return tail_recursive_array_sum(arr[1:], arr_sum + arr[0])


tic = time.time()
print(tail_recursive_array_sum(fact4())) 
toc = time.time()
(toc-tic)*1000

#Targil 4, 2: The functional, Regular recursion

def func(x):
  if x >10000:
    return []
  return  [x]+ func(x+1)

def recursive_array_sum(arr):
    if len(arr) == 0:
        return 0
    return arr[0] + recursive_array_sum(arr[1:])


tic = time.time()
L=func(1)
print(recursive_array_sum(L))

toc = time.time()
(toc-tic)*1000

# Targil 4, 3: The imperative
def gcd(x, y):
    while y != 0:
        (x, y) = (y, x % y)
    return x

tic = time.time()
print(gcd(60,80))  
toc = time.time()
(toc-tic)*1000

# Targil 4, 3: The functional, Tail recursion

tic = time.time()
gcd = lambda a,b : a if not b else gcd(b, a%b)
print(gcd(18,60))
toc = time.time()
(toc-tic)*1000

#Targil 4, 3: The functional, Regular recursion
def gcd(a,b):
    if b > a:
        return gcd(b,a)
    r = a%b
    if r == 0:
        return b
    return gcd(r,b)

tic = time.time()
print(gcd(15,50))
toc = time.time()
(toc-tic)*1000

# Targil 4, 4: The imperative
def lcm(x, y):
  if x > y:
      z = x
  else:
      z = y
  while(True):
      if((z % x == 0) and (z % y == 0)):
          lcmm = z
          break
      z += 1
  return lcmm

tic = time.time()
print(lcm(60,80)) 
toc = time.time()
(toc-tic)*1000

# Targil 4, 4: The functional, Tail recursion

from functools import reduce
from math import gcd

tic = time.time()
gcd = lambda a,b : a if not b else gcd(b, a%b)
numbers=[18,60]
lcm= reduce((lambda x, y: int(x * y / gcd(x, y))), numbers)
print(lcm)
toc = time.time()
(toc-tic)*1000

#Targil 4, 4: The functional, Regular recursion
def lcm(a, b):
  t = a % b
  if t == 0: return a
  return a * lcm(b, t) / t

tic = time.time()
print(lcm(15,50))
toc = time.time()
(toc-tic)*1000

# Targil 4, 5: The imperative
def sumfib(n):
  sumFib=1
  a,b = 1,1
  for i in range(n-1):
    a,b = b,a+b
    sumFib +=a
  return sumFib

tic = time.time()
print(sumfib(20))
toc = time.time()
(toc-tic)*1000

# Targil 4, 5: The functional, Tail recursion
def fib(n, a = 0, b = 1):
    if n == 0:
        return a
    if n == 1:
        return b
    return fib(n - 1, b, a + b);

def tail_recursive_array_sum(arr, arr_sum=0):
    if len(arr) == 0:
        return arr_sum
    return tail_recursive_array_sum(arr[1:], arr_sum + arr[0])    

tic = time.time()
list1=[recur_fibo(x) for x in range(1,21)]
print(tail_recursive_array_sum(list1)) 
toc = time.time()
(toc-tic)*1000

#Targil 4, 5: The functional, Regular recursion
def recur_fibo(n):
   if n <= 1:
       return n
   else:
       return (recur_fibo(n-1) + recur_fibo(n-2))
 
def recursive_array_sum(arr):
    if len(arr) == 0:
        return 0
    return arr[0] + recursive_array_sum(arr[1:])


tic = time.time()
list1=[recur_fibo(x) for x in range(1,21)]
print(recursive_array_sum(list1))
toc = time.time()
(toc-tic)*1000

# Targil 4, 6: The imperative
def prime100(L):
  newL=[1,2]
  for num in range(0, 101):
    for i in range(2, num):
        if num % i == 0:
            break
        else:
            newL.append(num)
            break
  return newL 

tic = time.time()
L=range(1,101)            
print(prime100(L)) 
toc = time.time()
(toc-tic)*1000

#Targil 4, 5: The functional, Tail recursion
def isPrime(n, i = 2):
    if (n <= 1):
        return True if(n == 1) else False
    if (n <= 2):
        return True if(n == 2) else False
    if (n % i == 0):
        return False
    if (i * i > n):
        return True
    return isPrime(n, i + 1)
 
tic = time.time() 
list1= range(1,100)
newL=[item for item in list1 if isPrime(item)]
print(newL)
toc = time.time()
(toc-tic)*1000

#Targil 4, 5: The functional, Regular recursion
def is_prime(n, div=n):

    if (n <= 1):
        return True if(n == 1) else False
    if (n <= 2):
        return True if(n == 2) else False
    if div> n/2.0: return True

    if n% div == 0:
        return False
    else:
        div+=1
        return is_prime(n,div)
 
tic = time.time() 
list1= range(1,100)
newL=[item for item in list1 if is_prime(item)]
print(newL)
toc = time.time()
(toc-tic)*1000